#
#	Makefile - P/ECE用Makefileの雛形
#
#	* Tue Dec  4 04:41:51 JST 2001 Naoyuki Sawa
#	- 作成開始。
#	* Sat May 25 15:43:00 JST 2002 Naoyuki Sawa
#	- ライブラリ構築用に修正。
#	* Thu Jun 13 12:30:00 JST 2002 Naoyuki Sawa
#	- zlib-1.1.4構築用に特化。

# P/ECE用zlibの作り方は、次のとおりです。
# あらかじめ、P/ECE開発環境を正しくセットアップしておいてください。
# - 「zlib Home Site(http://www.gzip.org/zlib/)」からソース一式をダウンロードします。
#   僕は http://www.libpng.org/pub/png/src/zlib-1.1.4.tar.gz をダウンロードしました。
# - ダウンロードした zlib-1.1.4.tar.gz を展開します。
#   zlib-1.1.4.tar.gz を展開すると、zlib-1.1.4 という名前のフォルダができます。
# - zlib-1.1.4 フォルダの中に、このファイル(Makefile)をコピーしてください。
#   zlib-1.1.4 フォルダの中には既に同じ名前のファイル(Makefile)がありますが、
#   上書きコピーしてしまって大丈夫です。
# - コマンドプロンプトを開き、zlib-1.1.4 フォルダへ移動してください。
# - コマンドプロンプトから、「make」とタイプしてください。
#   ライブラリの作成を開始します。
# - 「Librarian Completed」というメッセージが表示されたら、作成完了です。
# - アプリケーションからzlibを使うために必要なファイルは、次の3つだけです。
#   アプリケーションのプロジェクトフォルダにコピーして使ってください。
#   ・zlib.h:   zlibの関数を使うソースファイルからインクルードしてください。
#   ・zutil.h:  zlib.h の中からインクルードされています。
#               zlib.h と同じフォルダに置いてください。
#               ソースファイルから明示的にインクルードする必要はありません。
#   ・libz.lib: P/ECE用zlibライブラリの本体です。
#               アプリケーションのリンク時に、いっしょにリンクしてください。

#DEBUG=1

#############################################################################
#	定義：プロジェクト毎に書き換える部分（APP/LIB別）
#############################################################################

# プロジェクト名を指定してください。
# プロジェクト名はライブラリファイルのベース名となります。
PROJECT = tak

# オブジェクトファイルを列挙してください。
# * Thu Jun 13 12:30:00 JST 2002 Naoyuki Sawa
#   オブジェクトファイル一覧は、オリジナルのMakefileからコピーしました。
#   ただし、gzio.o(ソースファイルはgzio.c)だけは除外しました。
#   gzioは標準入出力関数に強く依存していて、P/ECEでは使えないからです。
OBJS =	misaki_gothic_tp_slim.o font.o task_sys.o graphic.o global.o util.o malloc_mgr.o

# プロジェクト別のコンパイラ・リンカオプションを定義してください。
# （インクルードパス、ライブラリパス、ライブラリファイルの列挙等）
# * Thu Jun 13 12:30:00 JST 2002 Naoyuki Sawa
#   zutil.hにある「#include <stddef.h>」の効果を抑制します。
#   P/ECE開発環境にもstddef.hは入っていますが、使ってはいけません。
#   wchar_tの定義がstdlib.hと衝突してしまうからです。
APP_CFLAGS  = -DSTDDEF_H
APP_LDFLAGS = 

#############################################################################
#	定義：全てのプロジェクトで共通な部分（APP/LIB共通）
#############################################################################

# CC,AS,LDの初期値は"cc","as","ld"です。
# Windows上のP/ECE開発環境では"gcc33","as33","lk33"を使います。
# これらのコマンドを明示してもいいのですが、
# "pcc33"を使えば自動的に適切なコマンドを呼び出してくれます。
# よってCC,AS,LD全てに共通の"pcc33"を指定することにしました。
CC = pcc33
AS = pcc33
LD = pcc33
# ライブラリアン(lib33)だけは"pcc33"から自動で呼ばれないので、
# 明示することにしました。
LIB = lib33

# サフィックスリストは初期値のままでも構いませんが、
# 不要なサフィックスが多くふくまれているので、
# 念のため必要なサフィックスのみを明示することにしました。
.SUFFIXES:
.SUFFIXES: .o .s .c

# 組み込みルールは"-o"オプションで出力ファイルを指定しています。
# pcc33は"-o"オプションで出力ファイルを指定できないので、
# 正しいサフィックスルールを明示する必要があります。
.c.o:
	$(CC) $(CFLAGS)  -c $<
.s.o:
	$(AS) $(ASFLAGS) -c $<

# 常に有効なコンパイラオプションを指定します。
# * GCC標準のオプション:
#	-Wall		全ての警告を有効にする
#	-Werror		警告をエラーとして扱う
#	-ansi		GCC拡張文法を無効にする  -> 外した
#	-pedantic	厳密なANSI準拠検査を行う -> 外した
# * S1C33特有のオプション:
#	-gp=0x0		グローバルポインタを使用
#	-near		分岐命令を2命令に展開
# * Thu Dec  6 21:50:15 JST 2001 Naoyuki Sawa
# - -pedanticはpcc33(gcc33)にはなく、エラーになるので省きました。
#   -ansiは使えるようですが、マニュアルに見当たりません。
#   とりあえず、-pedanticと共に省くことにしました。
CFLAGS  = -Wall -Werror -gp=0x0 -near -DPIECE

# * Wed Dec 12 05:04:06 JST 2001 Naoyuki Sawa
# - リンク時にシンボルファイルとマップファイルを生成するよう、
#   LDFLAGS に-lmと-lsオプションを追加しました。
LDFLAGS = -lm -ls

# 変化させるコンパイラオプションを指定します。
ifdef DEBUG
CFLAGS += -g  -DDEBUG
else
CFLAGS += -O2 -DNDEBUG
endif

# プロジェクト別のコンパイラ・リンカオプションを追加します。
CFLAGS  += $(APP_CFLAGS)
LDFLAGS += $(APP_LDFLAGS)

#############################################################################
#	アクション：全てのプロジェクトで共通な部分（APP/LIB共通）
#############################################################################

# ターゲット(TODO:説明書け)
all: lib
lib: $(PROJECT).lib
clean:
	-del *.o
	-del *.lib

# アクション(TODO:説明書け)
$(PROJECT).lib: $(OBJS)
	$(LIB) $(PROJECT).lib $(OBJS)

#############################################################################
#	依存関係：プロジェクト毎に書き換える部分（APP/LIB共通）
#############################################################################

# ※知らなかったけど、「*.o: *.h」こういう指定もできるみたいです。
#   例えばsample.oの依存関係を調べる場合、
#   * 既にsample.oが存在するなら、make実行時に*.oと*.hが展開されて、
#     sample.oがいずれかの.hファイルよりも新しければ再コンパイルします。
#   * sample.oが存在していなければ、makefile実行時に*.oが展開されても、
#     sample.oは含まれない、つまりsample.oの依存関係の指示はないけれど、
#     そもそもsample.oがないので、sample.cがコンパイルされる。
#   というふうに動作するみたいです。
#   全ての.cが全ての.hに依存する時は、この指定方法が簡単でいいです。
#   .hが一つも無いと展開エラーになるので、コメントアウトしてください。
# →さすがにあんまりなので、「$(OBJS): *.h」に修正しました。
$(OBJS): *.h